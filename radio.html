<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yellow Retro Radio</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #fdf6e3; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 40px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
            text-align: center;
            pointer-events: none;
            border-bottom: 5px solid #f1c40f;
            min-width: 300px;
            transition: opacity 0.3s;
        }
        #station-info { font-weight: bold; color: #2c3e50; font-size: 20px; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px; }
        #volume-info { color: #7f8c8d; font-size: 14px; text-transform: uppercase; letter-spacing: 2px; }
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
            cursor: pointer;
        }
        #overlay h1 { font-size: 54px; margin-bottom: 10px; color: #f1c40f; font-weight: 900; letter-spacing: -2px; }
        #overlay p { font-size: 20px; opacity: 0.7; }
        .hint {
            position: absolute;
            top: 25px;
            width: 100%;
            text-align: center;
            color: #7d8d8d;
            font-weight: 600;
            pointer-events: none;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 1px;
        }
        #color-picker {
            position: absolute;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 10;
        }
        .color-circle {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            border: 2px solid transparent;
            transition: transform 0.2s, border-color 0.2s;
        }
        .color-circle:hover {
            transform: scale(1.1);
        }
        .color-circle.selected {
            border: 3px solid #333;
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div id="overlay">
        <h1>RETRO RADIO</h1>
        <p>Click to build & play</p>
    </div>

    <div class="hint">Click Left Knob: Volume • Click Right Knob: Tuning • Drag to Rotate</div>

    <div id="ui">
        <div id="station-info">OFFLINE</div>
        <div id="volume-info">Volume: 50%</div>
    </div>

    <div id="color-picker"></div>

    <audio id="radio-player" crossorigin="anonymous"></audio>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Radio Logic & Streams ---
        const stations = [
            { name: "CLASSIC: Beethoven", url: "https://ice-the.musicradio.com/ClassicFMMP3" },
            { name: "ROCK: Classic", url: "https://stream.rockantenne.de/rockantenne/stream/mp3" },
            { name: "JAZZ: Swiss Jazz", url: "https://stream.srg-ssr.ch/m/rsj/mp3_128" },
            { name: "DANCE: Techno", url: "https://techno.stream.laut.fm/techno" },
            { name: "RELAX: Chillhop", url: "https://streams.ilovemusic.de/iloveradio10.mp3" }
        ];

        let currentStationIndex = 0;
        let volumeLevels = [0, 0.25, 0.5, 0.75, 1.0];
        let currentVolumeIndex = 2; // Start at 50%
        let isPoweredOn = false;
        let audioContext = null;

        const player = document.getElementById('radio-player');
        
        player.onerror = (e) => {
            console.warn("Stream failed, trying next...", e);
            if (isPoweredOn && player.volume > 0) setTimeout(cycleStation, 1000);
        };
        
        const stationDisplay = document.getElementById('station-info');
        const volumeDisplay = document.getElementById('volume-info');
        const overlay = document.getElementById('overlay');

        // --- Color Picker Logic ---
        const radioColors = [
            0xf1c40f, // Yellow (Default)
            0xe74c3c, // Red
            0x3498db, // Blue
            0x2ecc71, // Green
            0x9b59b6  // Purple
        ];
        
        const pickerContainer = document.getElementById('color-picker');
        radioColors.forEach((color, index) => {
            const circle = document.createElement('div');
            circle.className = `color-circle ${index === 0 ? 'selected' : ''}`;
            circle.style.backgroundColor = '#' + color.toString(16).padStart(6, '0');
            circle.onclick = () => {
                // Update selection UI
                document.querySelectorAll('.color-circle').forEach(c => c.classList.remove('selected'));
                circle.classList.add('selected');
                
                // Update Radio Material
                if (mats.yellow) {
                    mats.yellow.color.setHex(color);
                }
                // Update UI Border
                document.getElementById('ui').style.borderBottomColor = '#' + color.toString(16).padStart(6, '0');
                document.querySelector('#overlay h1').style.color = '#' + color.toString(16).padStart(6, '0');
            };
            pickerContainer.appendChild(circle);
        });

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function playStaticNoise() {
            if (!audioContext) return;
            
            const bufferSize = audioContext.sampleRate * 0.5; // 0.5 seconds
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                // White noise
                data[i] = (Math.random() * 2 - 1) * 0.3; // 0.3 volume
                
                // Fade out at end
                if (i > bufferSize - 1000) {
                    data[i] *= (bufferSize - i) / 1000;
                }
            }

            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;
            const gainNode = audioContext.createGain();
            gainNode.gain.value = volumeLevels[currentVolumeIndex]; // Match current volume
            
            noise.connect(gainNode);
            gainNode.connect(audioContext.destination);
            noise.start();
        }

        function playClickSound() {
            if (!audioContext) return;
            
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.connect(gain);
            gain.connect(audioContext.destination);
            
            // Short, mechanical click sound
            osc.frequency.setValueAtTime(800, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.05);
            
            gain.gain.setValueAtTime(0.15, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
            
            osc.start();
            osc.stop(audioContext.currentTime + 0.05);
        }

        function updateUI() {
            const vol = volumeLevels[currentVolumeIndex];
            
            if (vol === 0) {
                volumeDisplay.innerText = "Radio is off";
                stationDisplay.style.opacity = "0.5";
                // Don't change station text to off, just dim it
            } else {
                volumeDisplay.innerText = `Volume: ${Math.round(vol * 100)}%`;
                stationDisplay.style.opacity = "1";
            }
            
            // Update light intensity based on volume
            if (dialLight) {
                dialLight.intensity = vol > 0 ? 2.0 : 0;
            }
            if (dialMaterial) {
                dialMaterial.color.setHex(vol > 0 ? 0xffffff : 0xeeeeee);
                dialMaterial.emissiveIntensity = vol > 0 ? 0.8 : 0;
            }
            if (centralPanelMaterial) {
                centralPanelMaterial.color.setHex(vol > 0 ? 0xffffff : 0xcccccc); // White when On, Grey when Off
            }

            updateCats();
        }

        function updateStation() {
            if (!isPoweredOn) return;
            
            playStaticNoise();
            
            const station = stations[currentStationIndex];
            stationDisplay.innerText = station.name;
            player.src = station.url;
            player.load();
            
            // Only play if volume > 0
            if (volumeLevels[currentVolumeIndex] > 0) {
                player.play().catch(console.error);
            }
            
            updateCats(); // Re-check if cats should show for this station
        }

        function cycleVolume() {
            currentVolumeIndex = (currentVolumeIndex + 1) % volumeLevels.length;
            const vol = volumeLevels[currentVolumeIndex];
            player.volume = vol;
            
            if (vol > 0 && player.paused) {
                player.play().catch(console.error);
            }
            
            updateUI();
            return currentVolumeIndex;
        }

        function cycleStation() {
            currentStationIndex = (currentStationIndex + 1) % stations.length;
            updateStation();
            return currentStationIndex;
        }

        overlay.addEventListener('click', () => {
            initAudio();
            isPoweredOn = true;
            overlay.style.display = 'none';
            player.volume = volumeLevels[currentVolumeIndex];
            updateStation();
            updateUI();
        });

        // --- Three.js Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xfdf6e3);
        
        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(50, 40, 80);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 20;
        controls.maxDistance = 200;

        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(40, 60, 40);
        sun.castShadow = true;
        sun.shadow.mapSize.set(2048, 2048);
        sun.shadow.bias = -0.0001;
        scene.add(sun);

        const pointLight = new THREE.PointLight(0xfff0dd, 0.5);
        pointLight.position.set(-30, 20, 20);
        scene.add(pointLight);

        // --- Materials ---
        const mats = {
            yellow: new THREE.MeshStandardMaterial({ color: 0xf1c40f, roughness: 0.2 }),
            brown: new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.6 }),
            tan: new THREE.MeshStandardMaterial({ color: 0xd2b48c, roughness: 0.4 }),
            white: new THREE.MeshStandardMaterial({ color: 0xf5f5f5, roughness: 0.3 }),
            grey: new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.5 }),
            darkGrey: new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.7 }),
            black: new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 }),
            metal: new THREE.MeshStandardMaterial({ color: 0xbdc3c7, roughness: 0.2, metalness: 0.8 }),
            red: new THREE.MeshStandardMaterial({ color: 0xcc0000, roughness: 0.3 }),
            transparent: new THREE.MeshPhysicalMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.3, 
                roughness: 0, 
                metalness: 0.1,
                transmission: 0.9,
                thickness: 0.5
            }),
            emissiveDial: new THREE.MeshStandardMaterial({
                color: 0xeeeeee,
                emissive: 0xffffff,
                emissiveIntensity: 0,
                roughness: 0.4
            }),
            centralPanel: new THREE.MeshStandardMaterial({
                color: 0xcccccc, // Light grey when off
                roughness: 0.4
            })
        };

        let dialLight, dialMaterial = mats.emissiveDial, centralPanelMaterial = mats.centralPanel;

        // --- Model Construction ---
        const radioGroup = new THREE.Group();

        function createBrick(w, h, d, mat, x=0, y=0, z=0, parent=radioGroup) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            parent.add(mesh);
            
            // Studs (Top)
            if (h >= 0.4) { // Only if not a flat plate
                const studGeom = new THREE.CylinderGeometry(0.35, 0.35, 0.2, 12);
                const studMat = mat;
                
                // Determine stud grid
                const studW = Math.floor(w);
                const studD = Math.floor(d);
                
                if (studW >= 1 && studD >= 1) {
                    const instancedStud = new THREE.InstancedMesh(studGeom, studMat, studW * studD);
                    instancedStud.castShadow = true;
                    instancedStud.receiveShadow = true;
                    let idx = 0;
                    const dummy = new THREE.Object3D();
                    
                    for(let ix = 0; ix < studW; ix++) {
                        for(let iz = 0; iz < studD; iz++) {
                            dummy.position.set(
                                x - (studW-1)/2 + ix, 
                                y + h/2 + 0.1, 
                                z - (studD-1)/2 + iz
                            );
                            dummy.updateMatrix();
                            instancedStud.setMatrixAt(idx++, dummy.matrix);
                        }
                    }
                    parent.add(instancedStud);
                }
            }
            return mesh;
        }

        // --- 1. Main Chassis (Yellow) ---
        // Base plate
        createBrick(32, 1, 14, mats.yellow, 0, -10, 0);
        // Top plate
        createBrick(32, 1, 14, mats.yellow, 0, 10, 0);
        // Sides
        createBrick(2, 19, 14, mats.yellow, -15, 0, 0);
        createBrick(2, 19, 14, mats.yellow, 15, 0, 0);

        // --- 2. Front Face Details ---
        
        // Dial Surround (Dynamic Material)
        createBrick(28, 8, 2, mats.centralPanel, 0, 5, 5); // Main block
        createBrick(4, 8, 1, mats.centralPanel, -12, 5, 6.5); // Left knob housing
        createBrick(4, 8, 1, mats.centralPanel, 12, 5, 6.5); // Right knob housing

        // Dial Glass & Light
        const dialGlass = new THREE.Mesh(new THREE.BoxGeometry(20, 4, 0.5), mats.transparent);
        dialGlass.position.set(0, 5, 6.1);
        radioGroup.add(dialGlass);

        // Dial Backing (Emissive)
        const dialBacking = new THREE.Mesh(new THREE.BoxGeometry(19.8, 3.8, 0.1), mats.emissiveDial);
        dialBacking.position.set(0, 5, 5.8);
        radioGroup.add(dialBacking);

        // Dial Light Source
        dialLight = new THREE.PointLight(0xffffff, 0, 15);
        dialLight.position.set(0, 5, 6);
        radioGroup.add(dialLight);

        // Frequency Markings (Voxel lines inside dial)
        for(let i=-8; i<=8; i+=2) {
            const mark = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 0.05), mats.black);
            mark.position.set(i, 4.5, 5.9);
            radioGroup.add(mark);
        }

        // Needle
        const needle = new THREE.Mesh(new THREE.BoxGeometry(0.2, 3, 0.2), mats.red);
        needle.position.set(-8, 5, 6.0);
        radioGroup.add(needle);

        // Grill Area (White/Grey)
        createBrick(28, 11, 1, mats.white, 0, -5, 5); // Backing for grill
        
        // Grill Slats (Horizontal)
        for(let i=0; i<8; i++) {
            const yPos = -1 - i*1.2;
            const slat = new THREE.Mesh(new THREE.BoxGeometry(24, 0.4, 0.8), mats.grey);
            slat.position.set(0, yPos, 5.6);
            slat.castShadow = true;
            slat.receiveShadow = true;
            radioGroup.add(slat);
        }

        // --- 3. Back Panel (Technic Style) ---
        const backGroup = new THREE.Group();
        
        // Black Frame
        createBrick(28, 18, 1, mats.black, 0, 0, -6);
        
        // Technic Holes (Visualized as cylinders)
        const holeGeom = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 8);
        holeGeom.rotateX(Math.PI/2);
        const holesMesh = new THREE.InstancedMesh(holeGeom, mats.darkGrey, 150);
        
        let hIdx = 0;
        const hDummy = new THREE.Object3D();
        for(let x = -12; x <= 12; x += 2) {
            for(let y = -8; y <= 8; y += 2) {
                // Create a grid pattern with some "solid" areas skipped
                if (Math.abs(x) < 4 && Math.abs(y) < 4) continue; // Center solid block
                hDummy.position.set(x, y, -6);
                hDummy.updateMatrix();
                holesMesh.setMatrixAt(hIdx++, hDummy.matrix);
            }
        }
        backGroup.add(holesMesh);
        radioGroup.add(backGroup);


        // --- 4. Controls & Knobs ---
        const knobGeom = new THREE.CylinderGeometry(2.2, 2.2, 1.5, 32);
        knobGeom.rotateX(Math.PI/2);
        
        const leftKnob = new THREE.Mesh(knobGeom, mats.black);
        leftKnob.position.set(-12, 5, 7);
        leftKnob.name = "volumeKnob";
        radioGroup.add(leftKnob);

        // Add ridges to knobs
        const ridgeGeom = new THREE.BoxGeometry(0.4, 4.4, 1.6);
        const ridgeMesh = new THREE.InstancedMesh(ridgeGeom, mats.black, 6);
        const kDummy = new THREE.Object3D();
        for(let i=0; i<6; i++) {
            kDummy.rotation.z = (i / 6) * Math.PI;
            kDummy.updateMatrix();
            ridgeMesh.setMatrixAt(i, kDummy.matrix);
        }
        leftKnob.add(ridgeMesh.clone());
        
        const rightKnob = new THREE.Mesh(knobGeom, mats.black);
        rightKnob.position.set(12, 5, 7);
        rightKnob.name = "stationKnob";
        rightKnob.add(ridgeMesh.clone());
        radioGroup.add(rightKnob);


        // --- 5. Handle ---
        // Top Bar
        const handleBar = createBrick(34, 1, 2, mats.brown, 0, 15, 0);
        // Side Arms (angled)
        const armGeom = new THREE.BoxGeometry(1.5, 10, 2);
        const armL = new THREE.Mesh(armGeom, mats.grey);
        armL.position.set(-16, 10, 0);
        armL.rotation.z = 0.1;
        radioGroup.add(armL);

        const armR = new THREE.Mesh(armGeom, mats.grey);
        armR.position.set(16, 10, 0);
        armR.rotation.z = -0.1;
        radioGroup.add(armR);

        // Hinge pins
        const pinGeom = new THREE.CylinderGeometry(1, 1, 3, 16);
        pinGeom.rotateZ(Math.PI/2);
        const pinL = new THREE.Mesh(pinGeom, mats.grey);
        pinL.position.set(-16, 5, 0);
        radioGroup.add(pinL);
        const pinR = new THREE.Mesh(pinGeom, mats.grey);
        pinR.position.set(16, 5, 0);
        radioGroup.add(pinR);


        // --- 6. Antenna ---
        const antennaGroup = new THREE.Group();
        antennaGroup.position.set(10, 11, -5);
        antennaGroup.rotation.z = Math.PI / 4;
        antennaGroup.rotation.x = -Math.PI / 8;

        const segMat = mats.metal;
        // Base
        const antBase = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 1, 16), mats.black);
        antennaGroup.add(antBase);
        // Segments
        const seg1 = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 8, 16), segMat);
        seg1.position.y = 4;
        antennaGroup.add(seg1);
        const seg2 = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 8, 16), segMat);
        seg2.position.y = 11;
        antennaGroup.add(seg2);
        const seg3 = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 8, 16), segMat);
        seg3.position.y = 18;
        antennaGroup.add(seg3);
        // Tip
        const antTip = new THREE.Mesh(new THREE.SphereGeometry(0.4), segMat);
        antTip.position.y = 22;
        antennaGroup.add(antTip);

        radioGroup.add(antennaGroup);

        scene.add(radioGroup);

        // --- Music Notes Effect ---
        const notesGroup = new THREE.Group();
        scene.add(notesGroup);

        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.font = 'Bold 50px Arial';
        ctx.fillStyle = '#f1c40f';
        ctx.fillText('♪', 15, 50);
        const noteTexture = new THREE.CanvasTexture(canvas);
        const noteMaterial = new THREE.SpriteMaterial({ map: noteTexture, transparent: true });

        const activeNotes = [];
        const catsGroup = new THREE.Group();
        scene.add(catsGroup);

        const catColors = [
            0xffffff, // White
            0x333333, // Dark Grey
            0xffaa00, // Orange
            0x888888, // Grey
            0xdddddd, // Off-white
            0x222222, // Black
            0xd2b48c, // Tan
            0x8b4513, // Brown
            0xffe4c4, // Bisque/Cream
            0x708090  // Slate Grey
        ];

        function createLowPolyCat(color) {
            const catRoot = new THREE.Group();
            const catModel = new THREE.Group();
            
            // Fix Orientation: Cat built along -X, rotate to face +Z
            catModel.rotation.y = Math.PI / 2; 
            catRoot.add(catModel);

            const mat = new THREE.MeshLambertMaterial({ color: color, flatShading: true });
            
            // Body (Cylinder along X)
            const body = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.5, 4, 5), mat);
            body.rotation.z = Math.PI / 2;
            body.position.y = 2;
            catModel.add(body);

            // Head (at -X end)
            const head = new THREE.Mesh(new THREE.IcosahedronGeometry(1.2, 0), mat);
            head.position.set(-2.5, 3.5, 0);
            head.rotation.y = -Math.PI / 4; 
            catModel.add(head);

            // Ears
            const earGeom = new THREE.ConeGeometry(0.4, 1, 3);
            const leftEar = new THREE.Mesh(earGeom, mat);
            leftEar.position.set(-2.5, 4.5, 0.6);
            leftEar.rotation.x = 0.5;
            catModel.add(leftEar);
            
            const rightEar = new THREE.Mesh(earGeom, mat);
            rightEar.position.set(-2.5, 4.5, -0.6);
            rightEar.rotation.x = -0.5;
            catModel.add(rightEar);

            // Legs
            const legGeom = new THREE.CylinderGeometry(0.3, 0.2, 2, 4);
            const positions = [
                [-1.5, 1, 0.8], [-1.5, 1, -0.8],
                [1.5, 1, 0.8], [1.5, 1, -0.8]
            ];
            
            positions.forEach(pos => {
                const leg = new THREE.Mesh(legGeom, mat);
                leg.position.set(...pos);
                catModel.add(leg);
            });

            // Tail
            const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.1, 3, 4), mat);
            tail.position.set(2.5, 3, 0);
            tail.rotation.z = -Math.PI / 4;
            catModel.add(tail);

            catRoot.userData.model = catModel;
            return catRoot;
        }

        let catSpawnTimeout;

        function updateCats() {
            const vol = volumeLevels[currentVolumeIndex];
            const currentStation = stations[currentStationIndex];
            
            // Only show cats for "DANCE: Techno"
            const isTargetStation = currentStation.name.includes("Techno");
            
            let targetCount = 0;
            
            if (isTargetStation) {
                if (vol >= 0.25) targetCount = 4;
                if (vol >= 0.5) targetCount = 8;
                if (vol >= 0.75) targetCount = 16;
                if (vol >= 1.0) targetCount = 32;
            } else {
                targetCount = 0; // No cats for other stations
            }
            
            // Clear existing timeout if volume changed rapidly
            if (catSpawnTimeout) clearTimeout(catSpawnTimeout);

            if (targetCount === 0) {
                // Remove all cats immediately
                while(catsGroup.children.length > 0){ 
                    catsGroup.remove(catsGroup.children[0]); 
                }
            } else {
                // If we are turning ON (cats count is 0), wait 2 seconds
                if (catsGroup.children.length === 0) {
                    catSpawnTimeout = setTimeout(() => {
                        adjustCatCount(targetCount);
                    }, 2000);
                } else {
                    // Already on, adjust immediately
                    adjustCatCount(targetCount);
                }
            }
        }

        function adjustCatCount(target) {
            const current = catsGroup.children.length;
            
            // Get currently used colors to avoid duplicates if possible
            const usedColors = new Set();
            catsGroup.children.forEach(c => {
                // Traverse to find material color
                c.userData.model.children.forEach(mesh => {
                    if (mesh.material && mesh.material.color) usedColors.add(mesh.material.color.getHex());
                });
            });

            if (current < target) {
                // Add cats
                for (let i = current; i < target; i++) {
                    // Pick a unique color
                    let available = catColors.filter(c => !usedColors.has(c));
                    if (available.length === 0) available = catColors; // Fallback
                    const color = available[Math.floor(Math.random() * available.length)];
                    usedColors.add(color);

                    const cat = createLowPolyCat(color);
                    
                    // Spawn far away (outside typical viewport)
                    const angle = Math.random() * Math.PI * 2;
                    const spawnRadius = 150; 
                    const targetRadius = 25 + Math.random() * 15;
                    
                    cat.position.set(Math.cos(angle) * spawnRadius, -10, Math.sin(angle) * spawnRadius);
                    cat.lookAt(0, -5, 0); // Root looks at center
                    
                    cat.userData = {
                        model: cat.userData.model, // Ref to inner model
                        targetRadius: targetRadius,
                        angle: angle,
                        dancePhase: Math.random() * Math.PI * 2,
                        speed: 0.15 + Math.random() * 0.1
                    };
                    
                    catsGroup.add(cat);
                }
            } else if (current > target) {
                // Remove cats
                for (let i = current; i > target; i--) {
                    catsGroup.remove(catsGroup.children[catsGroup.children.length - 1]);
                }
            }
        }

        function spawnNote() {
            const note = new THREE.Sprite(noteMaterial);
            note.position.set(0, 0, 0);
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.1 + Math.random() * 0.1;
            const velocity = new THREE.Vector3(Math.cos(angle) * speed, 0.1 + Math.random() * 0.2, Math.sin(angle) * speed);
            note.scale.set(3, 3, 3);
            notesGroup.add(note);
            activeNotes.push({ sprite: note, velocity: velocity, age: 0 });
        }

        // --- Interaction ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function handleClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([leftKnob, rightKnob], true);

            if (intersects.length > 0) {
                // Find the knob parent if we hit a child (ridge)
                let clicked = intersects[0].object;
                while(clicked.parent && clicked.name !== "volumeKnob" && clicked.name !== "stationKnob" && clicked.parent !== radioGroup) {
                    clicked = clicked.parent;
                }

                if (clicked.name === "volumeKnob") {
                    playClickSound(); // Click sound
                    cycleVolume();
                    leftKnob.rotation.z -= Math.PI / 4;
                } else if (clicked.name === "stationKnob") {
                    playClickSound(); // Click sound
                    const idx = cycleStation();
                    rightKnob.rotation.z -= Math.PI / 4;
                    const targetX = -8 + (idx / (stations.length - 1)) * 16;
                    needle.position.x = targetX;
                }
            }
        }

        window.addEventListener('mousedown', handleClick);

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            // Note Animation
            if (isPoweredOn && volumeLevels[currentVolumeIndex] > 0 && !player.paused) {
                if (Math.random() < 0.05) spawnNote();
            }
            
            // Cat Animation (Walking & Dancing)
            if (catsGroup.children.length > 0) {
                const time = Date.now() * 0.005; 
                catsGroup.children.forEach(cat => {
                    if (cat.userData) {
                        const dist = Math.sqrt(cat.position.x * cat.position.x + cat.position.z * cat.position.z);
                        const model = cat.userData.model;

                        if (dist > cat.userData.targetRadius) {
                            // Walking towards center
                            const moveSpeed = 0.3;
                            cat.position.x -= Math.cos(cat.userData.angle) * moveSpeed;
                            cat.position.z -= Math.sin(cat.userData.angle) * moveSpeed;
                            
                            // Walking Animation (Tilt inner model)
                            model.rotation.x = Math.sin(time * 3 + cat.userData.dancePhase) * 0.15; // Rock body
                            model.position.y = Math.abs(Math.sin(time * 3 + cat.userData.dancePhase)) * 0.8; // Hop
                        } else {
                            // Dancing in place
                            model.rotation.x = Math.sin(time * 2 + cat.userData.dancePhase) * 0.2; // Rolling sway
                            model.rotation.y = Math.PI / 2 + Math.sin(time) * 0.2; // Look around
                            model.position.y = 0; 
                        }
                    }
                });
            }

            for (let i = activeNotes.length - 1; i >= 0; i--) {
                const noteData = activeNotes[i];
                const sprite = noteData.sprite;
                sprite.position.add(noteData.velocity);
                noteData.age += 1;
                sprite.material.opacity = 1 - (noteData.age / 100);
                if (noteData.age > 100) {
                    notesGroup.remove(sprite);
                    activeNotes.splice(i, 1);
                }
            }
            
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize UI
        updateUI();
        animate();
    </script>
</body>
</html>
