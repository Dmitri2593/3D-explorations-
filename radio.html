<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mint Retro Radio</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #e8e8e8;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 40px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
            text-align: center;
            pointer-events: none;
            border-bottom: 5px solid #98d4bb;
            min-width: 300px;
            transition: opacity 0.3s;
        }

        #station-info {
            font-weight: bold;
            color: #2c3e50;
            font-size: 20px;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #volume-info {
            color: #7f8c8d;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
            cursor: pointer;
        }

        #overlay h1 {
            font-size: 54px;
            margin-bottom: 10px;
            color: #98d4bb;
            font-weight: 900;
            letter-spacing: -2px;
        }

        #overlay p {
            font-size: 20px;
            opacity: 0.7;
        }

        .hint {
            position: absolute;
            top: 25px;
            width: 100%;
            text-align: center;
            color: #7d8d8d;
            font-weight: 600;
            pointer-events: none;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 1px;
        }

        #color-picker {
            position: absolute;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 10;
        }

        .color-circle {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            border: 2px solid transparent;
            transition: transform 0.2s, border-color 0.2s;
        }

        .color-circle:hover {
            transform: scale(1.1);
        }

        .color-circle.selected {
            border: 3px solid #333;
            transform: scale(1.1);
        }
    </style>
</head>

<body>
    <div id="overlay">
        <h1>RETRO RADIO</h1>
        <p>Click to build & play</p>
    </div>

    <div class="hint">Click Left Knob: Volume • Click Right Knob: Tuning • Drag to Rotate</div>

    <div id="ui">
        <div id="station-info">OFFLINE</div>
        <div id="volume-info">Volume: 50%</div>
    </div>

    <div id="color-picker"></div>

    <audio id="radio-player" crossorigin="anonymous"></audio>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Radio Logic & Streams ---
        const stations = [
            { name: "CLASSIC: Beethoven", url: "https://ice-the.musicradio.com/ClassicFMMP3" },
            { name: "ROCK: Classic", url: "https://stream.rockantenne.de/rockantenne/stream/mp3" },
            { name: "JAZZ: Swiss Jazz", url: "https://stream.srg-ssr.ch/m/rsj/mp3_128" },
            { name: "DANCE: Techno", url: "https://techno.stream.laut.fm/techno" },
            { name: "RELAX: Chillhop", url: "https://streams.ilovemusic.de/iloveradio10.mp3" }
        ];

        let currentStationIndex = 0;
        let volumeLevels = [0, 0.25, 0.5, 0.75, 1.0];
        let currentVolumeIndex = 2; // Start at 50%
        let isPoweredOn = false;
        let audioContext = null;

        const player = document.getElementById('radio-player');

        player.onerror = (e) => {
            console.warn("Stream failed, trying next...", e);
            if (isPoweredOn && player.volume > 0) setTimeout(cycleStation, 1000);
        };

        const stationDisplay = document.getElementById('station-info');
        const volumeDisplay = document.getElementById('volume-info');
        const overlay = document.getElementById('overlay');

        // --- Color Picker Logic ---
        const radioColors = [
            0x98d4bb, // Mint Green (Default)
            0xf1c40f, // Yellow 
            0xe74c3c, // Red
            0x3498db, // Blue
            0x9b59b6  // Purple
        ];

        const pickerContainer = document.getElementById('color-picker');
        radioColors.forEach((color, index) => {
            const circle = document.createElement('div');
            circle.className = `color-circle ${index === 0 ? 'selected' : ''}`;
            circle.style.backgroundColor = '#' + color.toString(16).padStart(6, '0');
            circle.onclick = () => {
                // Update selection UI
                document.querySelectorAll('.color-circle').forEach(c => c.classList.remove('selected'));
                circle.classList.add('selected');

                // Update Radio Material (mint body color)
                if (mats.mint) {
                    mats.mint.color.setHex(color);
                    // Also update the darker shade
                    const darkerColor = new THREE.Color(color).multiplyScalar(0.85);
                    mats.mintDark.color.copy(darkerColor);
                }
                // Update UI Border
                document.getElementById('ui').style.borderBottomColor = '#' + color.toString(16).padStart(6, '0');
                document.querySelector('#overlay h1').style.color = '#' + color.toString(16).padStart(6, '0');
            };
            pickerContainer.appendChild(circle);
        });

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function playStaticNoise() {
            if (!audioContext) return;

            const bufferSize = audioContext.sampleRate * 0.5; // 0.5 seconds
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                // White noise
                data[i] = (Math.random() * 2 - 1) * 0.3; // 0.3 volume

                // Fade out at end
                if (i > bufferSize - 1000) {
                    data[i] *= (bufferSize - i) / 1000;
                }
            }

            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;
            const gainNode = audioContext.createGain();
            gainNode.gain.value = volumeLevels[currentVolumeIndex]; // Match current volume

            noise.connect(gainNode);
            gainNode.connect(audioContext.destination);
            noise.start();
        }

        function playClickSound() {
            if (!audioContext) return;

            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.connect(gain);
            gain.connect(audioContext.destination);

            // Short, mechanical click sound
            osc.frequency.setValueAtTime(800, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.05);

            gain.gain.setValueAtTime(0.15, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);

            osc.start();
            osc.stop(audioContext.currentTime + 0.05);
        }

        function updateUI() {
            const vol = volumeLevels[currentVolumeIndex];

            if (vol === 0) {
                volumeDisplay.innerText = "Radio is off";
                stationDisplay.style.opacity = "0.5";
                // Don't change station text to off, just dim it
            } else {
                volumeDisplay.innerText = `Volume: ${Math.round(vol * 100)}%`;
                stationDisplay.style.opacity = "1";
            }

            // Update light intensity based on volume
            // (Dial light removed to prevent flickering - using scene lighting only)
            // Dial area updates handled by dialMaterial above

            updateCats();
        }

        function updateStation() {
            if (!isPoweredOn) return;

            playStaticNoise();

            const station = stations[currentStationIndex];
            stationDisplay.innerText = station.name;
            player.src = station.url;
            player.load();

            // Only play if volume > 0
            if (volumeLevels[currentVolumeIndex] > 0) {
                player.play().catch(console.error);
            }

            updateCats(); // Re-check if cats should show for this station
        }

        function cycleVolume() {
            currentVolumeIndex = (currentVolumeIndex + 1) % volumeLevels.length;
            const vol = volumeLevels[currentVolumeIndex];
            player.volume = vol;

            if (vol > 0 && player.paused) {
                player.play().catch(console.error);
            }

            updateUI();
            return currentVolumeIndex;
        }

        function cycleStation() {
            currentStationIndex = (currentStationIndex + 1) % stations.length;
            updateStation();
            return currentStationIndex;
        }

        overlay.addEventListener('click', () => {
            initAudio();
            isPoweredOn = true;
            overlay.style.display = 'none';
            player.volume = volumeLevels[currentVolumeIndex];
            updateStation();
            updateUI();
        });

        // --- Three.js Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xe8e8e8);

        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(50, 40, 80);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Shadows disabled to prevent flickering during rotation
        renderer.shadowMap.enabled = false;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 20;
        controls.maxDistance = 200;

        // Lights - Simple setup without shadows
        scene.add(new THREE.AmbientLight(0xffffff, 0.8));  // Increased ambient
        const sun = new THREE.DirectionalLight(0xffffff, 1.0);
        sun.position.set(40, 60, 40);
        // Shadow casting disabled
        scene.add(sun);

        // Secondary fill light from opposite side
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
        fillLight.position.set(-40, 30, -40);
        scene.add(fillLight);

        // --- Materials (Matching Reference Images) ---
        const mats = {
            // Main body - Mint Green
            mint: new THREE.MeshStandardMaterial({ color: 0x98d4bb, roughness: 0.3 }),
            mintDark: new THREE.MeshStandardMaterial({ color: 0x7ec4a7, roughness: 0.35 }),
            // Accent - Orange/Tan for dial area and handle
            orange: new THREE.MeshStandardMaterial({ color: 0xd4915a, roughness: 0.4 }),
            orangeLight: new THREE.MeshStandardMaterial({ color: 0xe6a86b, roughness: 0.35 }),
            // Speaker grill
            white: new THREE.MeshStandardMaterial({ color: 0xf5f5f0, roughness: 0.3 }),
            cream: new THREE.MeshStandardMaterial({ color: 0xeeeee8, roughness: 0.35 }),
            // Greys for handle supports, antenna
            grey: new THREE.MeshStandardMaterial({ color: 0xa8a8a8, roughness: 0.4 }),
            greyLight: new THREE.MeshStandardMaterial({ color: 0xc0c0c0, roughness: 0.35 }),
            greyDark: new THREE.MeshStandardMaterial({ color: 0x707070, roughness: 0.5 }),
            // Knobs and back panel
            black: new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.6 }),
            blackMatte: new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 }),
            // Metal for antenna
            metal: new THREE.MeshStandardMaterial({ color: 0xb0b0b0, roughness: 0.2, metalness: 0.7 }),
            // Red accent
            red: new THREE.MeshStandardMaterial({ color: 0xcc3333, roughness: 0.4 }),
            // Dial display
            dialBg: new THREE.MeshStandardMaterial({ color: 0xf8f4e8, roughness: 0.3 }),
            transparent: new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.25,
                roughness: 0.1,
                metalness: 0.05,
                transmission: 0.85,
                thickness: 0.3
            }),
            emissiveDial: new THREE.MeshStandardMaterial({
                color: 0xfff8e8,
                emissive: 0xfff0d0,
                emissiveIntensity: 0,
                roughness: 0.3
            })
        };

        // Keep reference for dynamic updates
        let dialLight, dialMaterial = mats.emissiveDial;

        // --- Model Construction ---
        const radioGroup = new THREE.Group();

        // Helper function to create a voxel brick
        function voxel(w, h, d, mat, x = 0, y = 0, z = 0, parent = radioGroup) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            parent.add(mesh);
            return mesh;
        }

        // ============================================================
        // MAIN BODY - Mint Green Chassis
        // ============================================================
        const bodyWidth = 42;  // 50% wider (was 28)
        const bodyHeight = 16; // 50% shorter (was 32)
        const bodyDepth = 10;

        // Front face - mint green frame
        voxel(bodyWidth, bodyHeight, 1, mats.mint, 0, 0, bodyDepth / 2); // Front panel

        // Left side panel
        voxel(1, bodyHeight, bodyDepth, mats.mint, -bodyWidth / 2 + 0.5, 0, 0);
        // Right side panel
        voxel(1, bodyHeight, bodyDepth, mats.mint, bodyWidth / 2 - 0.5, 0, 0);

        // Top panel
        voxel(bodyWidth, 1, bodyDepth, mats.mint, 0, bodyHeight / 2 - 0.5, 0);
        // Bottom panel
        voxel(bodyWidth, 1, bodyDepth, mats.mint, 0, -bodyHeight / 2 + 0.5, 0);

        // Front face detail layers (stepped inward)
        voxel(bodyWidth - 2, bodyHeight - 2, 0.5, mats.mintDark, 0, 0, bodyDepth / 2 - 0.75);

        // ============================================================
        // DIAL SECTION - Orange/Tan Area at Top
        // ============================================================
        const dialSectionY = 4;  // Adjusted for shorter body
        const dialWidth = 32;    // Wider dial area
        const dialHeight = 5;

        // Orange dial surround
        voxel(dialWidth, dialHeight, 1.5, mats.orange, 0, dialSectionY, bodyDepth / 2 + 0.5);

        // Inner dial frame
        voxel(dialWidth - 2, dialHeight - 1, 0.5, mats.orangeLight, 0, dialSectionY, bodyDepth / 2 + 1);

        // Frequency display window (cream/white background)
        const displayWidth = 18;  // Wider display
        const displayHeight = 2.5;
        voxel(displayWidth, displayHeight, 0.3, mats.dialBg, 0, dialSectionY, bodyDepth / 2 + 1.3);

        // Glass overlay
        const dialGlass = new THREE.Mesh(
            new THREE.BoxGeometry(displayWidth + 0.5, displayHeight + 0.3, 0.2),
            mats.transparent
        );
        dialGlass.position.set(0, dialSectionY, bodyDepth / 2 + 1.5);
        radioGroup.add(dialGlass);

        // Dial backing (emissive when on)
        const dialBacking = new THREE.Mesh(
            new THREE.BoxGeometry(displayWidth - 0.2, displayHeight - 0.2, 0.1),
            mats.emissiveDial
        );
        dialBacking.position.set(0, dialSectionY, bodyDepth / 2 + 1.2);
        radioGroup.add(dialBacking);

        // Dial light removed - using scene lighting only

        // Frequency markings
        for (let i = -7; i <= 7; i++) {
            const markHeight = (i % 2 === 0) ? 1.2 : 0.6;
            const mark = voxel(0.15, markHeight, 0.1, mats.black, i * 1.1, dialSectionY - 0.3, bodyDepth / 2 + 1.4);
        }

        // Tuning needle (red)
        const needle = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, displayHeight - 0.3, 0.15),
            mats.red
        );
        needle.position.set(-7, dialSectionY, bodyDepth / 2 + 1.45);
        radioGroup.add(needle);

        // Small button below dial
        voxel(2, 1, 0.8, mats.black, 0, dialSectionY - 3.5, bodyDepth / 2 + 0.8);

        // ============================================================
        // KNOBS - Black Octagonal Style
        // ============================================================
        function createOctagonalKnob(x, y, z, name) {
            const knobGroup = new THREE.Group();
            knobGroup.position.set(x, y, z);
            knobGroup.name = name;

            // Main knob body (octagonal approximation using cylinder with 8 sides)
            const knobGeom = new THREE.CylinderGeometry(2.5, 2.5, 2, 8);
            knobGeom.rotateX(Math.PI / 2);
            const knobBody = new THREE.Mesh(knobGeom, mats.black);
            knobGroup.add(knobBody);

            // Center cap
            const capGeom = new THREE.CylinderGeometry(1.2, 1.2, 0.5, 8);
            capGeom.rotateX(Math.PI / 2);
            const cap = new THREE.Mesh(capGeom, mats.blackMatte);
            cap.position.z = 1;
            knobGroup.add(cap);

            // Grip ridges (cross pattern)
            for (let i = 0; i < 4; i++) {
                const ridge = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 5, 2.2),
                    mats.blackMatte
                );
                ridge.rotation.z = (i / 4) * Math.PI;
                ridge.position.z = 0;
                knobGroup.add(ridge);
            }

            // Pixelated edge detail (small cubes around perimeter)
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const px = Math.cos(angle) * 2.8;
                const py = Math.sin(angle) * 2.8;
                const pixel = voxel(0.6, 0.6, 0.6, mats.greyLight, px, py, 0.8, knobGroup);
            }

            radioGroup.add(knobGroup);
            return knobGroup;
        }

        const leftKnob = createOctagonalKnob(-16, dialSectionY, bodyDepth / 2 + 1.5, "volumeKnob");
        const rightKnob = createOctagonalKnob(16, dialSectionY, bodyDepth / 2 + 1.5, "stationKnob");

        // ============================================================
        // SPEAKER GRILL - White/Cream with Horizontal Slats
        // ============================================================
        const grillY = -4;        // Adjusted for shorter body
        const grillWidth = 36;    // Wider grill
        const grillHeight = 8;    // Shorter grill

        // White backing panel
        voxel(grillWidth, grillHeight, 1, mats.white, 0, grillY, bodyDepth / 2 + 0.2);

        // Horizontal grill slats
        const slatCount = 6;      // Fewer slats for shorter height
        const slatSpacing = grillHeight / (slatCount + 1);
        for (let i = 1; i <= slatCount; i++) {
            const slatY = grillY + grillHeight / 2 - i * slatSpacing;
            // Main slat
            voxel(grillWidth - 2, 0.5, 1.2, mats.cream, 0, slatY, bodyDepth / 2 + 0.8);
            // Shadow/gap effect
            voxel(grillWidth - 2, 0.3, 0.2, mats.greyDark, 0, slatY - 0.3, bodyDepth / 2 + 0.3);
        }

        // Vertical dividers in grill (creating grid pattern)
        for (let i = -3; i <= 3; i++) {
            if (i === 0) continue; // Skip center
            voxel(0.3, grillHeight - 2, 0.8, mats.cream, i * 5, grillY, bodyDepth / 2 + 0.9);
        }

        // Mint green border around grill
        voxel(grillWidth + 2, 1, 1.5, mats.mint, 0, grillY + grillHeight / 2 + 0.5, bodyDepth / 2 + 0.5);
        voxel(grillWidth + 2, 1, 1.5, mats.mint, 0, grillY - grillHeight / 2 - 0.5, bodyDepth / 2 + 0.5);
        voxel(1, grillHeight, 1.5, mats.mint, -grillWidth / 2 - 0.5, grillY, bodyDepth / 2 + 0.5);
        voxel(1, grillHeight, 1.5, mats.mint, grillWidth / 2 + 0.5, grillY, bodyDepth / 2 + 0.5);

        // Bottom accent bar (grey)
        voxel(grillWidth - 4, 1.5, 0.8, mats.grey, 0, grillY - grillHeight / 2 + 1.5, bodyDepth / 2 + 1);

        // ============================================================
        // LEFT SIDE DETAILS
        // ============================================================
        // Slider switch
        const switchY = -2;  // Adjusted for shorter body
        voxel(0.8, 3, 2, mats.greyLight, -bodyWidth / 2, switchY, 0);
        voxel(0.6, 1.5, 1.5, mats.grey, -bodyWidth / 2 - 0.3, switchY + 0.3, 0);

        // Side vents (small horizontal lines)
        for (let i = 0; i < 2; i++) {
            voxel(0.3, 0.5, 3, mats.greyDark, -bodyWidth / 2 - 0.2, 4 - i * 1.5, 0);
        }

        // ============================================================
        // RIGHT SIDE DETAILS
        // ============================================================
        // Additional side detail
        for (let i = 0; i < 2; i++) {
            voxel(0.3, 0.5, 3, mats.greyDark, bodyWidth / 2 + 0.2, 4 - i * 1.5, 0);
        }

        // ============================================================
        // HANDLE - Grey Supports with Orange Bar
        // ============================================================
        const handleY = bodyHeight / 2 + 2.5;  // Adjusted for shorter body

        // Grey side supports (stepped/blocky design)
        const supportGroup = new THREE.Group();

        // Left support column (smaller for shorter body)
        voxel(1.5, 4, 2, mats.grey, -bodyWidth / 2 + 1, bodyHeight / 2 - 1, 0, supportGroup);
        voxel(1.5, 3, 2.5, mats.greyLight, -bodyWidth / 2 + 1, bodyHeight / 2 + 2, 0, supportGroup);

        // Right support column
        voxel(1.5, 4, 2, mats.grey, bodyWidth / 2 - 1, bodyHeight / 2 - 1, 0, supportGroup);
        voxel(1.5, 3, 2.5, mats.greyLight, bodyWidth / 2 - 1, bodyHeight / 2 + 2, 0, supportGroup);

        // Handle bar (orange) - wider
        voxel(bodyWidth - 4, 2, 3, mats.orange, 0, handleY, 0, supportGroup);
        voxel(bodyWidth - 6, 1.5, 2.5, mats.orangeLight, 0, handleY, 0.5, supportGroup);

        // Handle connection brackets (grey)
        voxel(2, 2.5, 2.5, mats.grey, -bodyWidth / 2 + 3, handleY - 0.5, 0, supportGroup);
        voxel(2, 2.5, 2.5, mats.grey, bodyWidth / 2 - 3, handleY - 0.5, 0, supportGroup);

        radioGroup.add(supportGroup);

        // ============================================================
        // BACK PANEL - Black Technic Style with Holes
        // ============================================================
        const backZ = -bodyDepth / 2;

        // Main black back panel
        voxel(bodyWidth - 2, bodyHeight - 2, 1, mats.black, 0, 0, backZ);

        // Mint green border around back
        voxel(bodyWidth, 1.5, 1, mats.mint, 0, bodyHeight / 2 - 1, backZ - 0.3);
        voxel(bodyWidth, 1.5, 1, mats.mint, 0, -bodyHeight / 2 + 1, backZ - 0.3);
        voxel(1.5, bodyHeight, 1, mats.mint, -bodyWidth / 2 + 0.5, 0, backZ - 0.3);
        voxel(1.5, bodyHeight, 1, mats.mint, bodyWidth / 2 - 0.5, 0, backZ - 0.3);

        // Technic holes pattern (using cylinder instances) - adjusted for wider/shorter body
        const holeGeom = new THREE.CylinderGeometry(0.5, 0.5, 1.3, 8);
        holeGeom.rotateX(Math.PI / 2);

        // Calculate hole positions for different sections - wider layout
        const holeSections = [
            // Top row spanning width
            { x: -16, y: 4, cols: 10, rows: 2 },
            // Left middle section
            { x: -16, y: 0, cols: 5, rows: 2 },
            // Right middle section  
            { x: 6, y: 0, cols: 6, rows: 2 },
            // Bottom row spanning width
            { x: -16, y: -4, cols: 18, rows: 2 }
        ];

        let totalHoles = 0;
        holeSections.forEach(sec => totalHoles += sec.cols * sec.rows);

        const holesMesh = new THREE.InstancedMesh(holeGeom, mats.blackMatte, totalHoles);
        const hDummy = new THREE.Object3D();
        let hIdx = 0;

        holeSections.forEach(section => {
            for (let col = 0; col < section.cols; col++) {
                for (let row = 0; row < section.rows; row++) {
                    hDummy.position.set(
                        section.x + col * 1.8,
                        section.y - row * 1.8,
                        backZ - 0.3
                    );
                    hDummy.updateMatrix();
                    holesMesh.setMatrixAt(hIdx++, hDummy.matrix);
                }
            }
        });
        radioGroup.add(holesMesh);

        // Raised sections on back (rectangles representing components)
        voxel(8, 2, 0.5, mats.blackMatte, 12, 4, backZ - 0.6);
        voxel(5, 2, 0.5, mats.blackMatte, -14, 4, backZ - 0.6);
        // Additional raised component block on bottom right (matching technic style)
        voxel(6, 3, 0.5, mats.blackMatte, bodyWidth / 2 - 6, -3, backZ - 0.6);

        // ============================================================
        // ANTENNA - Multi-segment Telescoping
        // ============================================================
        const antennaGroup = new THREE.Group();
        antennaGroup.position.set(bodyWidth / 2 - 3, bodyHeight / 2 - 2, -2);

        // Antenna base mount (grey block)
        voxel(2, 2, 2, mats.grey, 0, 0, 0, antennaGroup);

        // Antenna pivot (dark grey)
        const pivotGeom = new THREE.CylinderGeometry(0.8, 0.8, 1.5, 8);
        const pivot = new THREE.Mesh(pivotGeom, mats.greyDark);
        pivot.rotation.z = Math.PI / 2;
        pivot.position.set(0, 1.5, 0);
        antennaGroup.add(pivot);

        // Antenna segments group (can be rotated as one unit)
        const antennaSegments = new THREE.Group();
        antennaSegments.position.set(0, 2, 0);
        antennaSegments.rotation.z = Math.PI / 4.5; // Angled
        antennaSegments.rotation.x = -0.1;

        // Base segment (thickest)
        const seg1Geom = new THREE.BoxGeometry(1.2, 12, 1.2);
        const seg1 = new THREE.Mesh(seg1Geom, mats.grey);
        seg1.position.y = 6;
        antennaSegments.add(seg1);

        // Middle segment
        const seg2Geom = new THREE.BoxGeometry(0.9, 10, 0.9);
        const seg2 = new THREE.Mesh(seg2Geom, mats.greyLight);
        seg2.position.y = 17;
        antennaSegments.add(seg2);

        // Top segment (thinnest)
        const seg3Geom = new THREE.BoxGeometry(0.6, 10, 0.6);
        const seg3 = new THREE.Mesh(seg3Geom, mats.metal);
        seg3.position.y = 27;
        antennaSegments.add(seg3);

        // Antenna tip
        const tipGeom = new THREE.BoxGeometry(1, 1.5, 1);
        const tip = new THREE.Mesh(tipGeom, mats.greyDark);
        tip.position.y = 33;
        antennaSegments.add(tip);

        antennaGroup.add(antennaSegments);
        radioGroup.add(antennaGroup);

        // ============================================================
        // BOTTOM DETAILS
        // ============================================================
        // Orange accent strip at bottom
        voxel(bodyWidth - 4, 1, bodyDepth + 1, mats.orange, 0, -bodyHeight / 2 - 0.5, 0);

        // Feet (small grey blocks) - spread wider for new body width
        voxel(3, 1, 2, mats.grey, -15, -bodyHeight / 2 - 0.5, 2);
        voxel(3, 1, 2, mats.grey, 15, -bodyHeight / 2 - 0.5, 2);
        voxel(3, 1, 2, mats.grey, -15, -bodyHeight / 2 - 0.5, -2);
        voxel(3, 1, 2, mats.grey, 15, -bodyHeight / 2 - 0.5, -2);

        // Position radio 20% closer to bottom
        radioGroup.position.y = -8;

        // Add radio to scene
        scene.add(radioGroup);

        // --- Music Notes Effect ---
        const notesGroup = new THREE.Group();
        scene.add(notesGroup);

        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        ctx.font = 'Bold 50px Arial';
        ctx.fillStyle = '#f1c40f';
        ctx.fillText('♪', 15, 50);
        const noteTexture = new THREE.CanvasTexture(canvas);
        const noteMaterial = new THREE.SpriteMaterial({ map: noteTexture, transparent: true });

        const activeNotes = [];
        const catsGroup = new THREE.Group();
        scene.add(catsGroup);

        const catColors = [
            0xffffff, // White
            0x333333, // Dark Grey
            0xffaa00, // Orange
            0x888888, // Grey
            0xdddddd, // Off-white
            0x222222, // Black
            0xd2b48c, // Tan
            0x8b4513, // Brown
            0xffe4c4, // Bisque/Cream
            0x708090  // Slate Grey
        ];

        function createLowPolyCat(color) {
            const catRoot = new THREE.Group();
            const catModel = new THREE.Group();

            // Fix Orientation: Cat built along -X, rotate to face +Z
            catModel.rotation.y = Math.PI / 2;
            catRoot.add(catModel);

            const mat = new THREE.MeshLambertMaterial({ color: color, flatShading: true });

            // Body (Cylinder along X)
            const body = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.5, 4, 5), mat);
            body.rotation.z = Math.PI / 2;
            body.position.y = 2;
            catModel.add(body);

            // Head (at -X end)
            const head = new THREE.Mesh(new THREE.IcosahedronGeometry(1.2, 0), mat);
            head.position.set(-2.5, 3.5, 0);
            head.rotation.y = -Math.PI / 4;
            catModel.add(head);

            // Ears
            const earGeom = new THREE.ConeGeometry(0.4, 1, 3);
            const leftEar = new THREE.Mesh(earGeom, mat);
            leftEar.position.set(-2.5, 4.5, 0.6);
            leftEar.rotation.x = 0.5;
            catModel.add(leftEar);

            const rightEar = new THREE.Mesh(earGeom, mat);
            rightEar.position.set(-2.5, 4.5, -0.6);
            rightEar.rotation.x = -0.5;
            catModel.add(rightEar);

            // Legs
            const legGeom = new THREE.CylinderGeometry(0.3, 0.2, 2, 4);
            const positions = [
                [-1.5, 1, 0.8], [-1.5, 1, -0.8],
                [1.5, 1, 0.8], [1.5, 1, -0.8]
            ];

            positions.forEach(pos => {
                const leg = new THREE.Mesh(legGeom, mat);
                leg.position.set(...pos);
                catModel.add(leg);
            });

            // Tail
            const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.1, 3, 4), mat);
            tail.position.set(2.5, 3, 0);
            tail.rotation.z = -Math.PI / 4;
            catModel.add(tail);

            catRoot.userData.model = catModel;
            return catRoot;
        }

        let catSpawnTimeout;

        function updateCats() {
            const vol = volumeLevels[currentVolumeIndex];
            const currentStation = stations[currentStationIndex];

            // Only show cats for "DANCE: Techno"
            const isTargetStation = currentStation.name.includes("Techno");

            let targetCount = 0;

            if (isTargetStation) {
                if (vol >= 0.25) targetCount = 4;
                if (vol >= 0.5) targetCount = 8;
                if (vol >= 0.75) targetCount = 16;
                if (vol >= 1.0) targetCount = 32;
            } else {
                targetCount = 0; // No cats for other stations
            }

            // Clear existing timeout if volume changed rapidly
            if (catSpawnTimeout) clearTimeout(catSpawnTimeout);

            if (targetCount === 0) {
                // Remove all cats immediately
                while (catsGroup.children.length > 0) {
                    catsGroup.remove(catsGroup.children[0]);
                }
            } else {
                // If we are turning ON (cats count is 0), wait 2 seconds
                if (catsGroup.children.length === 0) {
                    catSpawnTimeout = setTimeout(() => {
                        adjustCatCount(targetCount);
                    }, 2000);
                } else {
                    // Already on, adjust immediately
                    adjustCatCount(targetCount);
                }
            }
        }

        function adjustCatCount(target) {
            const current = catsGroup.children.length;

            // Get currently used colors to avoid duplicates if possible
            const usedColors = new Set();
            catsGroup.children.forEach(c => {
                // Traverse to find material color
                c.userData.model.children.forEach(mesh => {
                    if (mesh.material && mesh.material.color) usedColors.add(mesh.material.color.getHex());
                });
            });

            if (current < target) {
                // Add cats
                for (let i = current; i < target; i++) {
                    // Pick a unique color
                    let available = catColors.filter(c => !usedColors.has(c));
                    if (available.length === 0) available = catColors; // Fallback
                    const color = available[Math.floor(Math.random() * available.length)];
                    usedColors.add(color);

                    const cat = createLowPolyCat(color);

                    // Spawn far away (outside typical viewport)
                    const angle = Math.random() * Math.PI * 2;
                    const spawnRadius = 150;
                    const targetRadius = 25 + Math.random() * 15;

                    // Position cats at same base level as radio (Y=-8 minus radio's half height)
                    const catGroundY = -8 - 8 - 1; // Radio Y position - half body height - offset
                    cat.position.set(Math.cos(angle) * spawnRadius, catGroundY, Math.sin(angle) * spawnRadius);
                    cat.lookAt(0, catGroundY, 0); // Root looks at center at ground level

                    cat.userData = {
                        model: cat.userData.model, // Ref to inner model
                        targetRadius: targetRadius,
                        angle: angle,
                        dancePhase: Math.random() * Math.PI * 2,
                        speed: 0.15 + Math.random() * 0.1
                    };

                    catsGroup.add(cat);
                }
            } else if (current > target) {
                // Remove cats
                for (let i = current; i > target; i--) {
                    catsGroup.remove(catsGroup.children[catsGroup.children.length - 1]);
                }
            }
        }

        function spawnNote() {
            const note = new THREE.Sprite(noteMaterial);
            note.position.set(0, 0, 0);
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.1 + Math.random() * 0.1;
            const velocity = new THREE.Vector3(Math.cos(angle) * speed, 0.1 + Math.random() * 0.2, Math.sin(angle) * speed);
            note.scale.set(3, 3, 3);
            notesGroup.add(note);
            activeNotes.push({ sprite: note, velocity: velocity, age: 0 });
        }

        // --- Interaction ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function handleClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([leftKnob, rightKnob], true);

            if (intersects.length > 0) {
                // Find the knob parent if we hit a child (ridge)
                let clicked = intersects[0].object;
                while (clicked.parent && clicked.name !== "volumeKnob" && clicked.name !== "stationKnob" && clicked.parent !== radioGroup) {
                    clicked = clicked.parent;
                }

                if (clicked.name === "volumeKnob") {
                    playClickSound(); // Click sound
                    cycleVolume();
                    leftKnob.rotation.z -= Math.PI / 4;
                } else if (clicked.name === "stationKnob") {
                    playClickSound(); // Click sound
                    const idx = cycleStation();
                    rightKnob.rotation.z -= Math.PI / 4;
                    const targetX = -8 + (idx / (stations.length - 1)) * 16;
                    needle.position.x = targetX;
                }
            }
        }

        window.addEventListener('mousedown', handleClick);

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Rotation disabled for now - uncomment to enable
            // radioGroup.rotation.y += 0.005;

            // Note Animation
            if (isPoweredOn && volumeLevels[currentVolumeIndex] > 0 && !player.paused) {
                if (Math.random() < 0.05) spawnNote();
            }

            // Cat Animation (Walking & Dancing)
            if (catsGroup.children.length > 0) {
                const time = Date.now() * 0.005;
                catsGroup.children.forEach(cat => {
                    if (cat.userData) {
                        const dist = Math.sqrt(cat.position.x * cat.position.x + cat.position.z * cat.position.z);
                        const model = cat.userData.model;

                        if (dist > cat.userData.targetRadius) {
                            // Walking towards center
                            const moveSpeed = 0.3;
                            cat.position.x -= Math.cos(cat.userData.angle) * moveSpeed;
                            cat.position.z -= Math.sin(cat.userData.angle) * moveSpeed;

                            // Walking Animation (Tilt inner model)
                            model.rotation.x = Math.sin(time * 3 + cat.userData.dancePhase) * 0.15; // Rock body
                            model.position.y = Math.abs(Math.sin(time * 3 + cat.userData.dancePhase)) * 0.8; // Hop
                        } else {
                            // Dancing in place
                            model.rotation.x = Math.sin(time * 2 + cat.userData.dancePhase) * 0.2; // Rolling sway
                            model.rotation.y = Math.PI / 2 + Math.sin(time) * 0.2; // Look around
                            model.position.y = 0;
                        }
                    }
                });
            }

            for (let i = activeNotes.length - 1; i >= 0; i--) {
                const noteData = activeNotes[i];
                const sprite = noteData.sprite;
                sprite.position.add(noteData.velocity);
                noteData.age += 1;
                sprite.material.opacity = 1 - (noteData.age / 100);
                if (noteData.age > 100) {
                    notesGroup.remove(sprite);
                    activeNotes.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize UI
        updateUI();
        animate();
    </script>
</body>

</html>